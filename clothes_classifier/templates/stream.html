<!-- templates/stream.html -->
{% extends 'base.html' %}

{% block title %}Живий стрім{% endblock %}

{% block content %}
<div class="stream-container">
    <div class="video-section">
        <h1>Реальний час: Класифікація одягу</h1>
        <div class="video-wrapper">
            <video id="video" autoplay playsinline></video>
            <canvas id="annotationCanvas"></canvas>
        </div>
        <button onclick="stopStream()">Зупинити</button>
        <div id="debug">Initializing...</div>
    </div>

    <div class="stats-section">
        <div class="stats-title">Загальна статистика</div>
        <div id="summary-stats">Очікування даних...</div>
        <div class="stats-title">Поточний кадр</div>
        <div id="predictions-container">Очікування прогнозів...</div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
    <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>
    <script>
        const video = document.getElementById('video');
        const annotationCanvas = document.getElementById('annotationCanvas');
        const ctx = annotationCanvas.getContext('2d');
        const summaryStats = document.getElementById('summary-stats');
        const predictionsContainer = document.getElementById('predictions-container');
        const debug = document.getElementById('debug');

        // Завантаження моделі ONNX
        let session;
        async function loadModel() {
            try {
                session = new onnx.InferenceSession();
                await session.loadModel('/static/models/best.onnx');
                debug.textContent = 'Model loaded successfully';
            } catch (e) {
                console.error('Model loading error:', e);
                debug.textContent = 'Error loading model: ' + e.message;
            }
        }
        loadModel();

        // Доступ до вебкамери та обробка кадрів
        navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 640 } })
            .then(stream => {
                video.srcObject = stream;
                debug.textContent = 'Webcam accessed';
                const processFrame = async () => {
                    if (!video.videoWidth || !session) return;

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 640;
                    tempCanvas.height = 640;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(video, 0, 0, 640, 640);

                    // Підготовка зображення для моделі
                    const imageData = tempCtx.getImageData(0, 0, 640, 640);
                    const inputTensor = new onnx.Tensor(new Float32Array(imageData.data.length / 4 * 3), 'float32', [1, 3, 640, 640]);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        inputTensor.data[i / 4 * 3] = imageData.data[i] / 255.0;     // R
                        inputTensor.data[i / 4 * 3 + 1] = imageData.data[i + 1] / 255.0; // G
                        inputTensor.data[i / 4 * 3 + 2] = imageData.data[i + 2] / 255.0; // B
                    }

                    // Виконання інференсу
                    const outputMap = await session.run([inputTensor]);
                    const outputTensor = outputMap.values().next().value; // Адаптуйте за структурою вашої моделі YOLO
                    processOutput(outputTensor);

                    requestAnimationFrame(processFrame);
                };
                requestAnimationFrame(processFrame);
            })
            .catch(err => {
                console.error('Webcam error:', err);
                debug.textContent = 'Webcam error: ' + err.message;
            });

        // Обробка результатів моделі
        function processOutput(outputTensor) {
            const annotations = [];
            for (let i = 0; i < outputTensor.dims[1]; i++) {
                const confidence = outputTensor.data[i * 6 + 4]; // Індекс впевненості
                if (confidence > 0.5) { // Поріг впевненості
                    annotations.push({
                        x: outputTensor.data[i * 6], // x-координата
                        y: outputTensor.data[i * 6 + 1], // y-координата
                        width: outputTensor.data[i * 6 + 2], // ширина
                        height: outputTensor.data[i * 6 + 3], // висота
                        classId: Math.floor(outputTensor.data[i * 6 + 5]), // ідентифікатор класу
                        confidence: confidence
                    });
                }
            }

            // Використання правильного порядку класів із names
            const CLASS_NAMES = ['Shoe', 'Tshirt', 'dress', 'hoodie', 'jacket', 'pants', 'shirt', 'short', 'skirt', 'sweater', 'sweatshirt', 'top'];
            const annotationsWithNames = annotations.map(a => ({
                ...a,
                class: CLASS_NAMES[a.classId] || `Unknown class ${a.classId}`
            }));

            // Малювання анотацій на canvas
            annotationCanvas.width = video.videoWidth;
            annotationCanvas.height = video.videoHeight;
            ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
            annotationsWithNames.forEach(annotation => {
                ctx.beginPath();
                ctx.rect(annotation.x, annotation.y, annotation.width, annotation.height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'red';
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.fillText(`${annotation.class} (${(annotation.confidence * 100).toFixed(1)}%)`,
                    annotation.x, annotation.y - 5);
            });

            // Статистика та JSON-вивід
            const summary = {};
            annotationsWithNames.forEach(a => summary[a.class] = (summary[a.class] || 0) + 1);
            summaryStats.innerHTML = Object.entries(summary)
                .map(([cls, count]) => `<div class="stats-item">${cls}: ${count} шт.</div>`)
                .join('');
            const predictions = annotationsWithNames.map(annotation => ({
                class: annotation.class,
                confidence: annotation.confidence,
                bbox: { x: annotation.x, y: annotation.y, width: annotation.width, height: annotation.height }
            }));
            predictionsContainer.innerHTML = `<pre>${JSON.stringify({ predictions }, null, 2)}</pre>`;
            debug.textContent = 'Processed frame';
        }

        // Зупинка стріму
        function stopStream() {
            video.srcObject?.getTracks().forEach(track => track.stop());
            ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
            debug.textContent = 'Stream stopped';
        }
    </script>
{% endblock %}